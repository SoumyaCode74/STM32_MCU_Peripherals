/**
 * @file stm32f429xx_i2c_driver.c
 * @brief Driver source code for I2C peripheral of STM32F429xx MCU
 * 		  Created: 15-02-2024
 * @author Soumyadeep Bose
 */

#include "stm32f429xx_i2c_driver.h"

static void I2C_GenerateStartCondition(I2C_RegAddr_t * pI2Cx){
	pI2Cx->CR1 |= BIT8;
}

static void I2C_ExecuteAddressPhase(I2C_RegAddr_t * pI2Cx, uint8_t slave_address){
	/*!< Left-shift the 7-bit slave address by 1 position and fill the LSB with 1 or 0 (R/NW) */
	slave_address <<= 1;
	slave_address &= ~BIT0;
	/*!< Put the slave address + r/nw bit in the I2C DR register */
	pI2Cx->DR = slave_address;

}
static void I2C_ClearADDRFlag(I2C_RegAddr_t * pI2Cx){
	/*!< Clear the ADDR flag by reading the SR1 then SR2 */
	pI2Cx->SR1 & 0xFFFFFFFF;
	pI2Cx->SR2 & 0xFFFFFFFF;
}
static void I2C_ExecuteDataPhase(I2C_RegAddr_t * pI2Cx, uint8_t * pData, uint32_t * pLength){
	uint32_t len = *pLength;
	while(len > 0){
		/*!< Wait for TXE to be HIGH */
		while(!I2C_GetFlagStatus(pI2Cx, I2C_TXE_F));
		pI2Cx->DR = *pData;
		pData++;
		len--;
	}
}
static void I2C_GenerateStopCondition(I2C_RegAddr_t * pI2Cx)
{
	pI2Cx->CR1 |= BIT9;
}
uint32_t GetPCLKFrequency(I2C_Handle_t * pI2CHandle){
	/*!< First find the clock source */
	/*!< Second, find the prescaler setting */
	/*!< Third, calculate and return the PCLK frequency */
	/*!< This function is not yet developed for PLL */
	uint8_t clock_source = pI2CHandle->hRCCPeriph->RCC_Config.clock_source;
	uint16_t prescaler	 = RCC_GetPrescaler(pI2CHandle->hRCCPeriph);
	if(clock_source == HSI || clock_source == PLL){
		return HSI_VALUE/prescaler;
	}
	else{
		return HSE_VALUE/prescaler;
	}
}

void I2C_Init(I2C_Handle_t * pI2CHandle){
	uint32_t pclk_freq			= 0;		///< Variable to store the current configured PCLK frequency
	/*!< Disable the I2C peripheral */
	pI2CHandle->pI2Cx->CR1 &= ~BIT0;
	/*!< Configure the mode (Standard or Fast) */
	if(pI2CHandle->I2C_PinConfig.I2C_SCLSpeed <= I2C_SM_SPEED_LIMIT){
		pI2CHandle->pI2Cx->CCR &= ~BIT15;
	}
	else{
		pI2CHandle->pI2Cx->CCR |= BIT15;
	}
	/*!< Configure the duty cycle of fast mode */
	if(pI2CHandle->I2C_PinConfig.I2C_SCLSpeed > I2C_SM_SPEED_LIMIT){
		if(pI2CHandle->I2C_PinConfig.I2C_FMDutyCycle == PERCENT_36){
			pI2CHandle->pI2Cx->CCR |= BIT14;
		}
		else{
			pI2CHandle->pI2Cx->CCR &= ~BIT14;
		}
	}
	/*!< Configure the speed of the serial clock (SCLK) */
	pclk_freq = GetPCLKFrequency(pI2CHandle);
	pI2CHandle->pI2Cx->CR2 &= ~(BIT5 | BIT4 | BIT3 | BIT2 | BIT1 | BIT0);
	pI2CHandle->pI2Cx->CR2 |= pclk_freq/(1000000);	///< Write the number corresponding to the APB clock frequency
	/*!< Configure the value of CCR	 */
	/*!< T_sclk = n x CCR x T_PCLK */
	if(pI2CHandle->I2C_PinConfig.I2C_SCLSpeed <= I2C_SM_SPEED_LIMIT){
		pI2CHandle->pI2Cx->CCR |= (pclk_freq/(2 * pI2CHandle->I2C_PinConfig.I2C_SCLSpeed)) & 0xFFF; ///< The first 12-bits of CCR register is CCR
	}
	else{
		if(pI2CHandle->I2C_PinConfig.I2C_FMDutyCycle == 0){
			pI2CHandle->pI2Cx->CCR |= (pclk_freq/(3 * pI2CHandle->I2C_PinConfig.I2C_SCLSpeed)) & 0xFFF;
		}

		else{
			pI2CHandle->pI2Cx->CCR |= (pclk_freq/(25 * pI2CHandle->I2C_PinConfig.I2C_SCLSpeed)) & 0xFFF;
		}
	}
	/*!< Configure the device address (if the device is slave) */
	/*!< Enable the peripheral */
	pI2CHandle->pI2Cx->CR1 |= BIT0;
	/*!< Enable the Acking after enabling I2C peripheral */
	pI2CHandle->pI2Cx->CR1 |= BIT10;
	/*!< Configure the rise time for I2C pins */
}

void I2C_MasterSendData(I2C_Handle_t * pI2CHandle, const uint8_t * pSlaveAddress, uint8_t * pData, uint32_t * pLength){
	I2C_RegAddr_t * pI2CPeriph = (I2C_RegAddr_t *)pI2CHandle->pI2Cx;
	/*!< Generate the START condition */
	I2C_GenerateStartCondition(pI2CPeriph);
	/*!< Wait for the start condition to occur */
	while(I2C_GetFlagStatus(pI2CPeriph, I2C_SB_F) == 0);	///< Wait until the status of SB is 1
	/*!< Put the address in data register */
	I2C_ExecuteAddressPhase(pI2CPeriph, *pSlaveAddress);
	/*!< Wait for ADDR flag to set */
	while(!I2C_GetFlagStatus(pI2CPeriph, I2C_ADDR_F));
	/*!< Clear the ADDR flag by reading SR1 then SR2 */
	I2C_ClearADDRFlag(pI2CPeriph);
	/*!< Start data transmission */
	I2C_ExecuteDataPhase(pI2CPeriph, pData, pLength);
	/*!< Wait for TXE=1, and BTF=1 */
	while(!I2C_GetFlagStatus(pI2CPeriph, I2C_TXE_F));
	while(!I2C_GetFlagStatus(pI2CPeriph, I2C_BTF_F));
	/*!< Generate the STOP condition */
	I2C_GenerateStopCondition(pI2CPeriph);

}
uint8_t I2C_GetFlagStatus(I2C_RegAddr_t * pI2Cx, uint8_t flag_pos){
	return (pI2Cx->SR1 & (0x1 << flag_pos));
}

void I2C_Event_Interrupt_Handler(I2C_Handle_t *pI2CHandle)
{
	//Interrupt handling for both master and slave mode of a device

	uint32_t temp1, temp2, temp3;

	temp1   = pI2CHandle->pI2Cx->CR2 & ( 1 << I2C_CR2_ITEVTEN) ;
	temp2   = pI2CHandle->pI2Cx->CR2 & ( 1 << I2C_CR2_ITBUFEN) ;

	temp3  = pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_SB);
	///< 1. Handle For interrupt generated by SB event
	///<	Note : SB flag is only applicable in Master mode
	if(temp1 && temp3)
	{
		///< The interrupt is generated because of SB event
		///< This block will not be executed in slave mode because for slave SB is always zero
		///< In this block lets executed the address phase
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx,pI2CHandle->DevAddr);
		}else if (pI2CHandle->TxRxState == I2C_BUSY_IN_RX )
		{
			I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx,pI2CHandle->DevAddr);
		}
	}

	temp3  = pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_ADDR);
	//2. Handle For interrupt generated by ADDR event
	//Note : When master mode : Address is sent
	//		 When Slave mode   : Address matched with own address
	if(temp1 && temp3)
	{
		// interrupt is generated because of ADDR event
		I2C_ClearADDRFlag(pI2CHandle);
	}

	temp3  = pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_BTF);
	//3. Handle For interrupt generated by BTF(Byte Transfer Finished) event
	if(temp1 && temp3)
	{
		//BTF flag is set
		if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			//make sure that TXE is also set .
			if(pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_TXE) )
			{
				//BTF, TXE = 1
				if(pI2CHandle->TxLen == 0 )
				{
					//1. generate the STOP condition
					if(pI2CHandle->Sr == I2C_DISABLE_SR)
						I2C_GenerateStopCondition(pI2CHandle->pI2Cx);

					//2. reset all the member elements of the handle structure.
					I2C_CloseSendData(pI2CHandle);

					//3. notify the application about transmission complete
					I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_TX_CMPLT);

				}
			}

		}else if (pI2CHandle->TxRxState == I2C_BUSY_IN_RX )
		{
			;
		}
	}

	temp3  = pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_STOPF);
	//4. Handle For interrupt generated by STOPF event
	// Note : Stop detection flag is applicable only slave mode . For master this flag will never be set
	//The below code block will not be executed by the master since STOPF will not set in master mode
	if(temp1 && temp3)
	{
		//STOF flag is set
		//Clear the STOPF ( i.e 1) read SR1 2) Write to CR1 )

		pI2CHandle->pI2Cx->CR1 |= 0x0000;

		//Notify the application that STOP is detected
		I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_STOP);
	}


	temp3  = pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_TXE);
	//5. Handle For interrupt generated by TXE event
	if(temp1 && temp2 && temp3)
	{
		//Check for device mode
		if(pI2CHandle->pI2Cx->SR2 & ( 1 << I2C_SR2_MSL))
		{
			//TXE flag is set
			//We have to do the data transmission
			if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
			{
				I2C_MasterHandleTXEInterrupt(pI2CHandle);
			}
		}else
		{
			//slave
			//make sure that the slave is really in transmitter mode
		    if(pI2CHandle->pI2Cx->SR2 & ( 1 << I2C_SR2_TRA))
		    {
		    	I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_DATA_REQ);
		    }
		}
	}

	temp3  = pI2CHandle->pI2Cx->SR1 & ( 1 << I2C_SR1_RXNE);
	//6. Handle For interrupt generated by RXNE event
	if(temp1 && temp2 && temp3)
	{
		//check device mode .
		if(pI2CHandle->pI2Cx->SR2 & ( 1 << I2C_SR2_MSL))
		{
			//The device is master

			//RXNE flag is set
			if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
			{
				I2C_MasterHandleRXNEInterrupt(pI2CHandle);

			}

		}else
		{
			//slave
			//make sure that the slave is really in receiver mode
			if(!(pI2CHandle->pI2Cx->SR2 & ( 1 << I2C_SR2_TRA)))
			{
				I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_DATA_RCV);
			}
		}
	}
}

void I2C_Error_Interrupt_Handler(I2C_Handle_t *pI2CHandle)
{

	uint32_t temp1,temp2;

    //Know the status of  ITERREN control bit in the CR2
	temp2 = (pI2CHandle->pI2Cx->CR2) & ( 1 << I2C_CR2_ITERREN);


/***********************Check for Bus error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1<< I2C_SR1_BERR);
	if(temp1  && temp2 )
	{
		//This is Bus error

		//Implement the code to clear the buss error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_BERR);

		//Implement the code to notify the application about the error
	   I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_BERR);
	}

/***********************Check for arbitration lost error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_ARLO );
	if(temp1  && temp2)
	{
		//This is arbitration lost error

		//Implement the code to clear the arbitration lost error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_ARLO);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_ARLO);

	}

/***********************Check for ACK failure  error************************************/

	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_AF);
	if(temp1  && temp2)
	{
		//This is ACK failure error

	    //Implement the code to clear the ACK failure error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_AF);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_AF);
	}

/***********************Check for Overrun/underrun error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_OVR);
	if(temp1  && temp2)
	{
		//This is Overrun/underrun

	    //Implement the code to clear the Overrun/underrun error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_OVR);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_OVR);
	}

/***********************Check for Time out error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_TIMEOUT);
	if(temp1  && temp2)
	{
		//This is Time out error

	    //Implement the code to clear the Time out error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_TIMEOUT);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_TIMEOUT);
	}

}

